-# rubocop:disable Style/CaseLikeIf
- nodeclass = case when toc_node.is_a?(TocTree::ManifestationNode) then 'manifestation-node' when toc_node.is_a?(TocTree::PlaceholderNode) then 'ph-node' else '' end
%li{ class: nodeclass, style: toc_node.is_a?(TocTree::ManifestationNode) ? '' : 'margin-top: 12px; margin-bottom: 10px;' }
  - if toc_node.is_a?(TocTree::ManifestationNode)
    - m = toc_node.manifestation
    - e = m.expression
    - w = e.work
    - genre = w.genre
    %span.sorting-metadata{ 'data-impressions': m.impressions_count, 'data-title': m.sort_title, 'data-pubdate': e.normalized_pub_date.present? ? e.normalized_pub_date.to_date.jd : nil, 'data-creation-date': w.normalized_creation_date.present? ? w.normalized_creation_date.to_date.jd : nil, 'data-upload-date': m.publication_date.to_date.jd }
    %span.by-icon-v02{ title: t(genre) }>= glyph_for_genre(genre)
    &nbsp;&rlm;
    :ruby
      label = m.title
      case role
      when :editor
        label += " / #{m.author_string}"
      when :translator
        label += " / #{authorities_string(m, :author)}"
        if m.translators.size > 1
          label += " / #{authorities_string(m, :translator, exclude_authority_id: authority_id)}"
        end
      when :author
        if m.authors.size > 1
          label += " / #{authorities_string(m, :author, exclude_authority_id: authority_id)}"
        end
        if m.translators.size > 0
          label += " #{t(:translated_by)} #{authorities_string(m, :translator)}"
        end
      end

    - if m.published?
      = link_to label, manifestation_path(m)
      %span.hidden.metadata-creation-date
        != "&nbsp;&nbsp;&nbsp;"
        - if w.date.present?
          = "(#{w.date})"
      %span.hidden.metadata-pubdate
        != "&nbsp;&nbsp;&nbsp;"
        - if e.date.present?
          = "(#{e.date})"
      %span.hidden.metadata-upload-date
        != "&nbsp;&nbsp;&nbsp;"
        = "(#{m.publication_date})"
      - if uncollected
        %span.metadata-source-edition
          %br
          - edition = e.source_edition || ''
          - edition.strip!
          - if e.date.present?
            - edition += ', '+e.date
          = edition
    - else
      = label
    %span.mtitle{ style: 'display:none' }= m.title
  - elsif toc_node.is_a?(TocTree::CollectionNode)
    -# Collection node
    - collection = toc_node.collection
    - type_prefix = collection.collection_type == 'uncollected' ? '' : textify_collection_type(collection.collection_type)
    - uncollected = collection.collection_type == 'uncollected'
    .cwrapper{ id: "cwrapper_#{collection.id}", 'data-nonce' => nonce, 'data-collection-id' => collection.id, class: uncollected ? 'uncollected' : '' }
      %span{style:'font-size:120%;'}
        %span.ctitle
          - if collection.created_at > 2.minutes.ago
            = link_to collection.title, collection_path(collection), {'data-focus-on-me': 'true'}
          - else
            = link_to collection.title, collection_path(collection)
        - if current_user && current_user.editor?
          - if type_prefix.present?
            = " (#{type_prefix})"
          != '&nbsp;&nbsp;&nbsp;'
          = link_to t(:edit), collection_manage_path(collection.id), style: 'font-size: 70%;'
        - collection.involved_authorities.reject{|x| x.authority_id == authority_id}.each do |ia|
          %p= "#{ia.authority.name} (#{textify_role(ia.role, ia.authority.gender)})"
        - if collection.publisher_line.present?
          %p
            - pyear = collection.pub_year.present? ? ", #{collection.pub_year}" : ''
            = "#{collection.publisher_line}#{pyear}"
      - is_involved = collection.involved_authorities.where(authority_id: authority_id).present?
      - if editable && (collection.collection_type == 'uncollected' || is_involved) # only show editable collections for collections where this particular author is a principal contributor
        = render partial: 'shared/manage_collection', locals: { collection: collection, title: collection.title, nonce: nonce }
      - else
        - unless full_toc
          - full_toc = is_involved # only show full TOC for collections where this particular author is a principal contributor
        - children = full_toc ? toc_node.sorted_children : toc_node.children_by_role(role, authority_id)
        - children.reject!{ |child| child.is_a?(TocTree::ManifestationNode) && child.manifestation.status != 'published' } # don't show deleted or unpublished manifestations in the TOC
        - unless children.empty?
          %ul.toclist
            = render partial: 'authors/toc_node', collection: children,
                    locals: { role: role, authority_id: authority_id, editable: editable, nonce: nonce, uncollected: uncollected, full_toc: full_toc }
      %br
  - elsif toc_node.is_a?(TocTree::PlaceholderNode)
    -# Placeholder, toc_node should be a String with HTML layout
    - ci = toc_node.collection_item
    - if toc_node.markdown.present?
      != MultiMarkdown.new(ci.markdown).to_html
    - else
      = ci.alt_title
-# rubocop:enable Style/CaseLikeIf
