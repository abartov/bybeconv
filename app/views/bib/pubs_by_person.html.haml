%h1= t(:bib_workshop)
%p= t(:pubs_by_person_instructions)

.container-fluid
  .row
    .col-md-6
      = render partial: 'find_bibs', locals: {remote: true}

      %table#bibs
        %tr
          %th= t(:title)
          %th= t(:author)
          %th= t(:publisher)
          %th= t(:year_published)
          %th= t(:language)
          %th= t(:comments)
          %th= t(:record_source)
          %th= t(:record_id)
          %th= t(:is_scanned)
          %th= t(:actions)
        = render partial: 'pubs', locals: {pubs: @pubs}
    .col-md-6
      .backend-field
        = label_tag t(:linked_author)
        = hidden_field_tag :person_id
        = autocomplete_field_tag :person, '', autocomplete_person_name_path, id_element: '#person_id', scopes: [:bib_not_done], 'data-noMatchesLabel' => t(:no_matches_found)
      = link_to t(:new_author), authors_new_path
      .card
        .card-content
          %h2= t(:pubs_by_author)
          %table#pubs
            %tbody

:javascript
  function moveit(elem){
    var person_id = $('#person_id').val();
    if (person_id == null || person_id == "") {
      alert("#{t(:select_person_first)}");
    } else {
      var row = elem.parentElement.parentElement;
      var status = (row.children[8].textContent == "#{t(:yes)}" ? "scanned" : "todo");
      elem.disabled = true;
      $.ajax({
          type: "POST",
          url: "#{publications_path}",
          data: { publication: {title: row.children[0].textContent , author_line: row.children[1].textContent, publisher_line: row.children[2].textContent,
            pub_year: row.children[3].textContent, language: row.children[4].textContent,
            notes: row.children[5].textContent, bib_source: row.children[6].textContent, source_id: row.children[7].children[0].href,
            person_id: person_id, status: status } },
          dataType: "script"
        }).done(function(xhr, status) {
          if(status == "success") {
            row.remove();
          } else {
            alert('error');
            elem.disabled = false;
          }
        });
    }
  };
  $(document).ready(function() {
    $('#person').bind('railsAutocomplete.select', function(event, data){
      //alert(data.item.id);
      $.ajax({
        url: "#{bib_person_path({person_id: 999})}".replace("999", data.item.id),
        dataType: "script"
      });
    });
  });