= form_for @ingestible do |f|
  - if @ingestible.errors.any?
    #error_explanation
      %h2= t('ingestible.invalid')
      %ul
        - @ingestible.errors.full_messages.each do |message|
          %li= message

  .field
    = f.label t('ingestible.title')
    = f.text_field :title, style: 'width:80%'
  .field{style: 'border: 1px solid #ccc; padding: 10px;'}
    %h3= t('ingestible.volume')
    = f.label t('ingestible.volume_by_author')
    = autocomplete_field_tag :author, '', autocomplete_authority_name_path, 'data-noMatchesLabel' => t(:no_matches_found), id: 'aterm', style: 'width:400px;', id_element: '#authority_id'
    = hidden_field_tag :authority_id, value: '', id: 'authority_id'
    = f.check_box :no_volume
    = f.label t('ingestible.no_volume')
    &nbsp;
    %span{id: 'explain_no_volume'}= '[?]'
    %br
    = select_tag :authority_volumes, [], {id: 'authority_volumes', style: 'display:none;'}
    %br

    = f.label t('ingestible.any_volume')
    = autocomplete_field_tag :volume, '', autocomplete_collection_title_path, 'data-noMatchesLabel' => t(:no_matches_found), id: 'cterm', style: 'width:400px;', id_element: '#insert_cid'
    = hidden_field_tag :insert_cid, value: '', id: 'insert_cid'

  .field
    = f.label :scenario
    = f.select :scenario, options_for_select(Ingestible.scenarios.map{|k,v| [t("ingestible.scenario.#{k}"), k]}, @ingestible.scenario)
    = f.label :status
    %b= t("ingestible.status.#{@ingestible.status}")
    = f.hidden_field :status, value: @ingestible.status
  %h2= t('ingestible.defaults')
  = f.label t(:genre)
  - genres = [[t(:mixed_genres), 'mixed']]+get_genres.map {|genre| [I18n.t(genre), genre]}
  = f.select :genre, options_for_select(genres, @ingestible.genre), {include_blank: true}
  = f.label t(:publisher)
  = f.text_field :publisher, required: true, style: 'width:400px;'
  = f.label t(:year_published)
  = f.text_field :year_published, style: 'width:100px;'
  %br
  = f.label t(:orig_lang)
  = f.select :orig_lang, options_for_select(get_langs.map {|lang| [textify_lang(lang), lang]}, @ingestible.orig_lang)
  = render partial: 'authorities', locals: {authorities: @ingestible.default_authorities}
  %hr
  .field
    = f.label :comments
    = f.text_area :comments
  .field
    = f.check_box :attach_photos
    = f.label t('ingestible.attach_photos')
    &nbsp;
    %span{id: 'explain_attach_photos'}= '[?]'
  .field
    = f.label :markdown
    = f.text_area :markdown, style: 'width:80%; height: 200px;'
  - if @ingestible.docx.present?
    %p
      = t('.current_file')
      = link_to @ingestible.docx.filename.to_s, url_for(@ingestible.docx)
      = t('.or_replace_file')
  - else
    %b= t(:upload_file)
    = t(:file_can_be_skipped)
  = f.file_field :docx
  .actions
    = f.submit t(:save)
:javascript
  $(document).ready(function() {
    $('#explain_no_volume').popover({content: 
    "#{t('ingestible.no_volume_explanation')}", 
    trigger: 'hover', placement: 'right'});
    $('#explain_attach_photos').popover({content: 
    "#{t('ingestible.attach_photos_explanation')}", 
    trigger: 'hover', placement: 'right'});
    $('#aterm').on('railsAutocomplete.select', function(event, data){
      $('#authority_id').val(data.item.id);
      // look up volumes by authority
      url = "#{authority_volumes_path}?id=" + data.item.id;
      $.ajax({
        url: url,
        success: function(data) {
          $('#authority_volumes').show();
          data['volumes'].forEach(function(volume) {
            $('#authority_volumes').append($('<option>', {
              value: volume.id,
              text: volume.title
            }));
          });
          data['publications'].forEach(function(publication) {
            $('#authority_volumes').append($('<option>', {
              value: 'P'+publication.id.toString(),
              text: "#{t('ingestible.new_volume')} " + publication.title
            }));
          });
        }
      });
    });
    $('#authority_volumes').on('change', function() {
      $('#insert_cid').val($('#authority_volumes').val());
    });
  });